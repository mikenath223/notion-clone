{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nvar _jsxFileName = \"/project/notion-clone/components/editableBlock/index.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport ContentEditable from \"react-contenteditable\";\nimport { Draggable } from \"react-beautiful-dnd\";\nimport styles from \"./styles.module.scss\";\nimport TagSelectorMenu from \"../tagSelectorMenu\";\nimport ActionMenu from \"../actionMenu\";\nimport DragHandleIcon from \"../../images/draggable.svg\";\nimport { setCaretToEnd, getCaretCoordinates, getSelection } from \"../../utils\";\nvar CMD_KEY = \"/\"; // library does not work with hooks\n\nvar EditableBlock = /*#__PURE__*/function (_React$Component) {\n  _inherits(EditableBlock, _React$Component);\n\n  var _super = _createSuper(EditableBlock);\n\n  function EditableBlock(props) {\n    var _this;\n\n    _classCallCheck(this, EditableBlock);\n\n    _this = _super.call(this, props);\n    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));\n    _this.handleFocus = _this.handleFocus.bind(_assertThisInitialized(_this));\n    _this.handleBlur = _this.handleBlur.bind(_assertThisInitialized(_this));\n    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_this));\n    _this.handleKeyUp = _this.handleKeyUp.bind(_assertThisInitialized(_this));\n    _this.handleMouseUp = _this.handleMouseUp.bind(_assertThisInitialized(_this));\n    _this.handleDragHandleClick = _this.handleDragHandleClick.bind(_assertThisInitialized(_this));\n    _this.openActionMenu = _this.openActionMenu.bind(_assertThisInitialized(_this));\n    _this.closeActionMenu = _this.closeActionMenu.bind(_assertThisInitialized(_this));\n    _this.openTagSelectorMenu = _this.openTagSelectorMenu.bind(_assertThisInitialized(_this));\n    _this.closeTagSelectorMenu = _this.closeTagSelectorMenu.bind(_assertThisInitialized(_this));\n    _this.handleTagSelection = _this.handleTagSelection.bind(_assertThisInitialized(_this));\n    _this.handleImageUpload = _this.handleImageUpload.bind(_assertThisInitialized(_this));\n    _this.addPlaceholder = _this.addPlaceholder.bind(_assertThisInitialized(_this));\n    _this.calculateActionMenuPosition = _this.calculateActionMenuPosition.bind(_assertThisInitialized(_this));\n    _this.calculateTagSelectorMenuPosition = _this.calculateTagSelectorMenuPosition.bind(_assertThisInitialized(_this));\n    _this.contentEditable = React.createRef();\n    _this.fileInput = null;\n    _this.state = {\n      htmlBackup: null,\n      html: \"\",\n      tag: \"p\",\n      imageUrl: \"\",\n      placeholder: false,\n      previousKey: null,\n      isTyping: false,\n      tagSelectorMenuOpen: false,\n      tagSelectorMenuPosition: {\n        x: null,\n        y: null\n      },\n      actionMenuOpen: false,\n      actionMenuPosition: {\n        x: null,\n        y: null\n      }\n    };\n    return _this;\n  } // To avoid unnecessary API calls, the block component fully owns the draft state\n  // i.e. while editing we only update the block component, only when the user\n  // finished editing (e.g. switched to next block), we update the page as well\n  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\n\n\n  _createClass(EditableBlock, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Add a placeholder if the first block has no sibling elements and no content\n      var hasPlaceholder = this.addPlaceholder({\n        block: this.contentEditable.current,\n        position: this.props.position,\n        content: this.props.html || this.props.imageUrl\n      });\n\n      if (!hasPlaceholder) {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          html: this.props.html,\n          tag: this.props.tag,\n          imageUrl: this.props.imageUrl\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      // update the page on the server if one of the following is true\n      // 1. user stopped typing and the html content has changed & no placeholder set\n      // 2. user changed the tag & no placeholder set\n      // 3. user changed the image & no placeholder set\n      var stoppedTyping = prevState.isTyping && !this.state.isTyping;\n      var hasNoPlaceholder = !this.state.placeholder;\n      var htmlChanged = this.props.html !== this.state.html;\n      var tagChanged = this.props.tag !== this.state.tag;\n      var imageChanged = this.props.imageUrl !== this.state.imageUrl;\n\n      if ((stoppedTyping && htmlChanged || tagChanged || imageChanged) && hasNoPlaceholder) {\n        this.props.updateBlock({\n          id: this.props.id,\n          html: this.state.html,\n          tag: this.state.tag,\n          imageUrl: this.state.imageUrl\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      // In case, the user deleted the block, we need to cleanup all listeners\n      document.removeEventListener(\"click\", this.closeActionMenu, false);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(e) {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        html: e.target.value\n      }));\n    }\n  }, {\n    key: \"handleFocus\",\n    value: function handleFocus() {\n      // If a placeholder is set, we remove it when the block gets focused\n      if (this.state.placeholder) {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          html: \"\",\n          placeholder: false,\n          isTyping: true\n        }));\n      } else {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          isTyping: true\n        }));\n      }\n    }\n  }, {\n    key: \"handleBlur\",\n    value: function handleBlur(e) {\n      // Show placeholder if block is still the only one and empty\n      var hasPlaceholder = this.addPlaceholder({\n        block: this.contentEditable.current,\n        position: this.props.position,\n        content: this.state.html || this.state.imageUrl\n      });\n\n      if (!hasPlaceholder) {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          isTyping: false\n        }));\n      }\n    }\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(e) {\n      if (e.key === CMD_KEY) {\n        // If the user starts to enter a command, we store a backup copy of\n        // the html. We need this to restore a clean version of the content\n        // after the content type selection was finished.\n        this.setState({\n          htmlBackup: this.state.html\n        });\n      } else if (e.key === \"Backspace\" && !this.state.html) {\n        this.props.deleteBlock({\n          id: this.props.id\n        });\n      } else if (e.key === \"Enter\" && this.state.previousKey !== \"Shift\" && !this.state.tagSelectorMenuOpen) {\n        // If the user presses Enter, we want to add a new block\n        // Only the Shift-Enter-combination should add a new paragraph,\n        // i.e. Shift-Enter acts as the default enter behaviour\n        e.preventDefault();\n        this.props.addBlock({\n          id: this.props.id,\n          html: this.state.html,\n          tag: this.state.tag,\n          imageUrl: this.state.imageUrl,\n          ref: this.contentEditable.current\n        });\n      } // We need the previousKey to detect a Shift-Enter-combination\n\n\n      this.setState({\n        previousKey: e.key\n      });\n    } // The openTagSelectorMenu function needs to be invoked on key up. Otherwise\n    // the calculation of the caret coordinates does not work properly.\n\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(e) {\n      if (e.key === CMD_KEY) {\n        this.openTagSelectorMenu(\"KEY_CMD\");\n      }\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp() {\n      var block = this.contentEditable.current;\n\n      var _getSelection = getSelection(block),\n          selectionStart = _getSelection.selectionStart,\n          selectionEnd = _getSelection.selectionEnd;\n\n      if (selectionStart !== selectionEnd) {\n        this.openActionMenu(block, \"TEXT_SELECTION\");\n      }\n    }\n  }, {\n    key: \"handleDragHandleClick\",\n    value: function handleDragHandleClick(e) {\n      var dragHandle = e.target;\n      this.openActionMenu(dragHandle, \"DRAG_HANDLE_CLICK\");\n    }\n  }, {\n    key: \"openActionMenu\",\n    value: function openActionMenu(parent, trigger) {\n      var _this2 = this;\n\n      var _this$calculateAction = this.calculateActionMenuPosition(parent, trigger),\n          x = _this$calculateAction.x,\n          y = _this$calculateAction.y;\n\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        actionMenuPosition: {\n          x: x,\n          y: y\n        },\n        actionMenuOpen: true\n      })); // Add listener asynchronously to avoid conflicts with\n      // the double click of the text selection\n\n      setTimeout(function () {\n        document.addEventListener(\"click\", _this2.closeActionMenu, false);\n      }, 100);\n    }\n  }, {\n    key: \"closeActionMenu\",\n    value: function closeActionMenu() {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        actionMenuPosition: {\n          x: null,\n          y: null\n        },\n        actionMenuOpen: false\n      }));\n      document.removeEventListener(\"click\", this.closeActionMenu, false);\n    }\n  }, {\n    key: \"openTagSelectorMenu\",\n    value: function openTagSelectorMenu(trigger) {\n      var _this$calculateTagSel = this.calculateTagSelectorMenuPosition(trigger),\n          x = _this$calculateTagSel.x,\n          y = _this$calculateTagSel.y;\n\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        tagSelectorMenuPosition: {\n          x: x,\n          y: y\n        },\n        tagSelectorMenuOpen: true\n      }));\n      document.addEventListener(\"click\", this.closeTagSelectorMenu, false);\n    }\n  }, {\n    key: \"closeTagSelectorMenu\",\n    value: function closeTagSelectorMenu() {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        htmlBackup: null,\n        tagSelectorMenuPosition: {\n          x: null,\n          y: null\n        },\n        tagSelectorMenuOpen: false\n      }));\n      document.removeEventListener(\"click\", this.closeTagSelectorMenu, false);\n    } // Convert editableBlock shape based on the chosen tag\n    // i.e. img = display <div><input /><img /></div> (input picker is hidden)\n    // i.e. every other tag = <ContentEditable /> with its tag and html content\n\n  }, {\n    key: \"handleTagSelection\",\n    value: function handleTagSelection(tag) {\n      var _this3 = this;\n\n      if (tag === \"img\") {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          tag: tag\n        }), function () {\n          _this3.closeTagSelectorMenu();\n\n          if (_this3.fileInput) {\n            // Open the native file picker\n            _this3.fileInput.click();\n          } // Add new block so that the user can continue writing\n          // after adding an image\n\n\n          _this3.props.addBlock({\n            id: _this3.props.id,\n            html: \"\",\n            tag: \"p\",\n            imageUrl: \"\",\n            ref: _this3.contentEditable.current\n          });\n        });\n      } else {\n        if (this.state.isTyping) {\n          // Update the tag and restore the html backup without the command\n          this.setState({\n            tag: tag,\n            html: this.state.htmlBackup\n          }, function () {\n            setCaretToEnd(_this3.contentEditable.current);\n\n            _this3.closeTagSelectorMenu();\n          });\n        } else {\n          this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n            tag: tag\n          }), function () {\n            _this3.closeTagSelectorMenu();\n          });\n        }\n      }\n    }\n  }, {\n    key: \"handleImageUpload\",\n    value: function () {\n      var _handleImageUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var pageId, imageFile, formData, response, data, imageUrl;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.fileInput && this.fileInput.files[0])) {\n                  _context.next = 19;\n                  break;\n                }\n\n                pageId = this.props.pageId;\n                imageFile = this.fileInput.files[0];\n                formData = new FormData();\n                formData.append(\"image\", imageFile);\n                _context.prev = 5;\n                _context.next = 8;\n                return fetch(\"\".concat(process.env.NEXT_PUBLIC_API, \"/pages/images?pageId=\").concat(pageId), {\n                  method: \"POST\",\n                  credentials: \"include\",\n                  body: formData\n                });\n\n              case 8:\n                response = _context.sent;\n                _context.next = 11;\n                return response.json();\n\n              case 11:\n                data = _context.sent;\n                imageUrl = data.imageUrl;\n                this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n                  imageUrl: imageUrl\n                }));\n                _context.next = 19;\n                break;\n\n              case 16:\n                _context.prev = 16;\n                _context.t0 = _context[\"catch\"](5);\n                console.log(_context.t0);\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 16]]);\n      }));\n\n      function handleImageUpload() {\n        return _handleImageUpload.apply(this, arguments);\n      }\n\n      return handleImageUpload;\n    }() // Show a placeholder for blank pages\n\n  }, {\n    key: \"addPlaceholder\",\n    value: function addPlaceholder(_ref) {\n      var block = _ref.block,\n          position = _ref.position,\n          content = _ref.content;\n      var isFirstBlockWithoutHtml = position === 1 && !content;\n      var isFirstBlockWithoutSibling = !block.parentElement.nextElementSibling;\n\n      if (isFirstBlockWithoutHtml && isFirstBlockWithoutSibling) {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          html: \"Type a page title...\",\n          tag: \"h1\",\n          imageUrl: \"\",\n          placeholder: true,\n          isTyping: false\n        }));\n        return true;\n      } else {\n        return false;\n      }\n    } // If we have a text selection, the action menu should be displayed above\n    // If we have a drag handle click, the action menu should be displayed beside\n\n  }, {\n    key: \"calculateActionMenuPosition\",\n    value: function calculateActionMenuPosition(parent, initiator) {\n      switch (initiator) {\n        case \"TEXT_SELECTION\":\n          var _getCaretCoordinates = getCaretCoordinates(false),\n              endX = _getCaretCoordinates.x,\n              endY = _getCaretCoordinates.y; // fromEnd\n\n\n          var _getCaretCoordinates2 = getCaretCoordinates(true),\n              startX = _getCaretCoordinates2.x,\n              startY = _getCaretCoordinates2.y; // fromStart\n\n\n          var middleX = startX + (endX - startX) / 2;\n          return {\n            x: middleX,\n            y: startY\n          };\n\n        case \"DRAG_HANDLE_CLICK\":\n          var x = parent.offsetLeft - parent.scrollLeft + parent.clientLeft - 90;\n          var y = parent.offsetTop - parent.scrollTop + parent.clientTop + 35;\n          return {\n            x: x,\n            y: y\n          };\n\n        default:\n          return {\n            x: null,\n            y: null\n          };\n      }\n    } // If the user types the \"/\" command, the tag selector menu should be display above\n    // If it is triggered by the action menu, it should be positioned relatively to its initiator\n\n  }, {\n    key: \"calculateTagSelectorMenuPosition\",\n    value: function calculateTagSelectorMenuPosition(initiator) {\n      switch (initiator) {\n        case \"KEY_CMD\":\n          var _getCaretCoordinates3 = getCaretCoordinates(true),\n              caretLeft = _getCaretCoordinates3.x,\n              caretTop = _getCaretCoordinates3.y;\n\n          return {\n            x: caretLeft,\n            y: caretTop\n          };\n\n        case \"ACTION_MENU\":\n          var _this$state$actionMen = this.state.actionMenuPosition,\n              actionX = _this$state$actionMen.x,\n              actionY = _this$state$actionMen.y;\n          return {\n            x: actionX - 40,\n            y: actionY\n          };\n\n        default:\n          return {\n            x: null,\n            y: null\n          };\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      return __jsx(React.Fragment, null, this.state.tagSelectorMenuOpen && __jsx(TagSelectorMenu, {\n        position: this.state.tagSelectorMenuPosition,\n        closeMenu: this.closeTagSelectorMenu,\n        handleSelection: this.handleTagSelection,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 349,\n          columnNumber: 11\n        }\n      }), this.state.actionMenuOpen && __jsx(ActionMenu, {\n        position: this.state.actionMenuPosition,\n        actions: {\n          deleteBlock: function deleteBlock() {\n            return _this4.props.deleteBlock({\n              id: _this4.props.id\n            });\n          },\n          turnInto: function turnInto() {\n            return _this4.openTagSelectorMenu(\"ACTION_MENU\");\n          }\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 356,\n          columnNumber: 11\n        }\n      }), __jsx(Draggable, {\n        draggableId: this.props.id,\n        index: this.props.position,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 364,\n          columnNumber: 9\n        }\n      }, function (provided, snapshot) {\n        return __jsx(\"div\", _extends({\n          ref: provided.innerRef,\n          className: styles.draggable\n        }, provided.draggableProps, {\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 366,\n            columnNumber: 13\n          }\n        }), _this4.state.tag !== \"img\" && __jsx(ContentEditable, {\n          innerRef: _this4.contentEditable,\n          \"data-position\": _this4.props.position,\n          \"data-tag\": _this4.state.tag,\n          html: _this4.state.html,\n          onChange: _this4.handleChange,\n          onFocus: _this4.handleFocus,\n          onBlur: _this4.handleBlur,\n          onKeyDown: _this4.handleKeyDown,\n          onKeyUp: _this4.handleKeyUp,\n          onMouseUp: _this4.handleMouseUp,\n          tagName: _this4.state.tag,\n          className: [styles.block, _this4.state.isTyping || _this4.state.actionMenuOpen || _this4.state.tagSelectorMenuOpen ? styles.blockSelected : null, _this4.state.placeholder ? styles.placeholder : null, snapshot.isDragging ? styles.isDragging : null].join(\" \"),\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 372,\n            columnNumber: 17\n          }\n        }), _this4.state.tag === \"img\" && __jsx(\"div\", {\n          \"data-position\": _this4.props.position,\n          \"data-tag\": _this4.state.tag,\n          ref: _this4.contentEditable,\n          className: [styles.image, _this4.state.actionMenuOpen || _this4.state.tagSelectorMenuOpen ? styles.blockSelected : null].join(\" \"),\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 397,\n            columnNumber: 17\n          }\n        }, __jsx(\"input\", {\n          id: \"\".concat(_this4.props.id, \"_fileInput\"),\n          name: _this4.state.tag,\n          type: \"file\",\n          onChange: _this4.handleImageUpload,\n          ref: function ref(_ref2) {\n            return _this4.fileInput = _ref2;\n          },\n          hidden: true,\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 408,\n            columnNumber: 19\n          }\n        }), !_this4.state.imageUrl && __jsx(\"label\", {\n          htmlFor: \"\".concat(_this4.props.id, \"_fileInput\"),\n          className: styles.fileInputLabel,\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 417,\n            columnNumber: 21\n          }\n        }, \"No Image Selected. Click To Select.\"), _this4.state.imageUrl && __jsx(\"img\", {\n          src: process.env.NEXT_PUBLIC_API + \"/\" + _this4.state.imageUrl,\n          alt: /[^\\/]+(?=\\.[^\\/.]*$)/.exec(_this4.state.imageUrl)[0],\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 425,\n            columnNumber: 21\n          }\n        })), __jsx(\"span\", _extends({\n          role: \"button\",\n          tabIndex: \"0\",\n          className: styles.dragHandle,\n          onClick: _this4.handleDragHandleClick\n        }, provided.dragHandleProps, {\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 434,\n            columnNumber: 15\n          }\n        }), __jsx(\"img\", {\n          src: DragHandleIcon,\n          alt: \"Icon\",\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 441,\n            columnNumber: 17\n          }\n        })));\n      }));\n    }\n  }]);\n\n  return EditableBlock;\n}(React.Component);\n\nexport default EditableBlock;","map":{"version":3,"sources":["/project/notion-clone/components/editableBlock/index.js"],"names":["ContentEditable","Draggable","styles","TagSelectorMenu","ActionMenu","DragHandleIcon","setCaretToEnd","getCaretCoordinates","getSelection","CMD_KEY","EditableBlock","props","handleChange","bind","handleFocus","handleBlur","handleKeyDown","handleKeyUp","handleMouseUp","handleDragHandleClick","openActionMenu","closeActionMenu","openTagSelectorMenu","closeTagSelectorMenu","handleTagSelection","handleImageUpload","addPlaceholder","calculateActionMenuPosition","calculateTagSelectorMenuPosition","contentEditable","React","createRef","fileInput","state","htmlBackup","html","tag","imageUrl","placeholder","previousKey","isTyping","tagSelectorMenuOpen","tagSelectorMenuPosition","x","y","actionMenuOpen","actionMenuPosition","hasPlaceholder","block","current","position","content","setState","prevProps","prevState","stoppedTyping","hasNoPlaceholder","htmlChanged","tagChanged","imageChanged","updateBlock","id","document","removeEventListener","e","target","value","key","deleteBlock","preventDefault","addBlock","ref","selectionStart","selectionEnd","dragHandle","parent","trigger","setTimeout","addEventListener","click","files","pageId","imageFile","formData","FormData","append","fetch","process","env","NEXT_PUBLIC_API","method","credentials","body","response","json","data","console","log","isFirstBlockWithoutHtml","isFirstBlockWithoutSibling","parentElement","nextElementSibling","initiator","endX","endY","startX","startY","middleX","offsetLeft","scrollLeft","clientLeft","offsetTop","scrollTop","clientTop","caretLeft","caretTop","actionX","actionY","turnInto","provided","snapshot","innerRef","draggable","draggableProps","blockSelected","isDragging","join","image","fileInputLabel","exec","dragHandleProps","Component"],"mappings":"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","sourcesContent":["import ContentEditable from \"react-contenteditable\";\nimport { Draggable } from \"react-beautiful-dnd\";\n\nimport styles from \"./styles.module.scss\";\nimport TagSelectorMenu from \"../tagSelectorMenu\";\nimport ActionMenu from \"../actionMenu\";\nimport DragHandleIcon from \"../../images/draggable.svg\";\nimport { setCaretToEnd, getCaretCoordinates, getSelection } from \"../../utils\";\n\nconst CMD_KEY = \"/\";\n\n// library does not work with hooks\nclass EditableBlock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleFocus = this.handleFocus.bind(this);\n    this.handleBlur = this.handleBlur.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleKeyUp = this.handleKeyUp.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleDragHandleClick = this.handleDragHandleClick.bind(this);\n    this.openActionMenu = this.openActionMenu.bind(this);\n    this.closeActionMenu = this.closeActionMenu.bind(this);\n    this.openTagSelectorMenu = this.openTagSelectorMenu.bind(this);\n    this.closeTagSelectorMenu = this.closeTagSelectorMenu.bind(this);\n    this.handleTagSelection = this.handleTagSelection.bind(this);\n    this.handleImageUpload = this.handleImageUpload.bind(this);\n    this.addPlaceholder = this.addPlaceholder.bind(this);\n    this.calculateActionMenuPosition = this.calculateActionMenuPosition.bind(\n      this\n    );\n    this.calculateTagSelectorMenuPosition = this.calculateTagSelectorMenuPosition.bind(\n      this\n    );\n    this.contentEditable = React.createRef();\n    this.fileInput = null;\n    this.state = {\n      htmlBackup: null,\n      html: \"\",\n      tag: \"p\",\n      imageUrl: \"\",\n      placeholder: false,\n      previousKey: null,\n      isTyping: false,\n      tagSelectorMenuOpen: false,\n      tagSelectorMenuPosition: {\n        x: null,\n        y: null,\n      },\n      actionMenuOpen: false,\n      actionMenuPosition: {\n        x: null,\n        y: null,\n      },\n    };\n  }\n\n  // To avoid unnecessary API calls, the block component fully owns the draft state\n  // i.e. while editing we only update the block component, only when the user\n  // finished editing (e.g. switched to next block), we update the page as well\n  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\n\n  componentDidMount() {\n    // Add a placeholder if the first block has no sibling elements and no content\n    const hasPlaceholder = this.addPlaceholder({\n      block: this.contentEditable.current,\n      position: this.props.position,\n      content: this.props.html || this.props.imageUrl,\n    });\n    if (!hasPlaceholder) {\n      this.setState({\n        ...this.state,\n        html: this.props.html,\n        tag: this.props.tag,\n        imageUrl: this.props.imageUrl,\n      });\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // update the page on the server if one of the following is true\n    // 1. user stopped typing and the html content has changed & no placeholder set\n    // 2. user changed the tag & no placeholder set\n    // 3. user changed the image & no placeholder set\n    const stoppedTyping = prevState.isTyping && !this.state.isTyping;\n    const hasNoPlaceholder = !this.state.placeholder;\n    const htmlChanged = this.props.html !== this.state.html;\n    const tagChanged = this.props.tag !== this.state.tag;\n    const imageChanged = this.props.imageUrl !== this.state.imageUrl;\n    if (\n      ((stoppedTyping && htmlChanged) || tagChanged || imageChanged) &&\n      hasNoPlaceholder\n    ) {\n      this.props.updateBlock({\n        id: this.props.id,\n        html: this.state.html,\n        tag: this.state.tag,\n        imageUrl: this.state.imageUrl,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    // In case, the user deleted the block, we need to cleanup all listeners\n    document.removeEventListener(\"click\", this.closeActionMenu, false);\n  }\n\n  handleChange(e) {\n    this.setState({ ...this.state, html: e.target.value });\n  }\n\n  handleFocus() {\n    // If a placeholder is set, we remove it when the block gets focused\n    if (this.state.placeholder) {\n      this.setState({\n        ...this.state,\n        html: \"\",\n        placeholder: false,\n        isTyping: true,\n      });\n    } else {\n      this.setState({ ...this.state, isTyping: true });\n    }\n  }\n\n  handleBlur(e) {\n    // Show placeholder if block is still the only one and empty\n    const hasPlaceholder = this.addPlaceholder({\n      block: this.contentEditable.current,\n      position: this.props.position,\n      content: this.state.html || this.state.imageUrl,\n    });\n    if (!hasPlaceholder) {\n      this.setState({ ...this.state, isTyping: false });\n    }\n  }\n\n  handleKeyDown(e) {\n    if (e.key === CMD_KEY) {\n      // If the user starts to enter a command, we store a backup copy of\n      // the html. We need this to restore a clean version of the content\n      // after the content type selection was finished.\n      this.setState({ htmlBackup: this.state.html });\n    } else if (e.key === \"Backspace\" && !this.state.html) {\n      this.props.deleteBlock({ id: this.props.id });\n    } else if (\n      e.key === \"Enter\" &&\n      this.state.previousKey !== \"Shift\" &&\n      !this.state.tagSelectorMenuOpen\n    ) {\n      // If the user presses Enter, we want to add a new block\n      // Only the Shift-Enter-combination should add a new paragraph,\n      // i.e. Shift-Enter acts as the default enter behaviour\n      e.preventDefault();\n      this.props.addBlock({\n        id: this.props.id,\n        html: this.state.html,\n        tag: this.state.tag,\n        imageUrl: this.state.imageUrl,\n        ref: this.contentEditable.current,\n      });\n    }\n    // We need the previousKey to detect a Shift-Enter-combination\n    this.setState({ previousKey: e.key });\n  }\n\n  // The openTagSelectorMenu function needs to be invoked on key up. Otherwise\n  // the calculation of the caret coordinates does not work properly.\n  handleKeyUp(e) {\n    if (e.key === CMD_KEY) {\n      this.openTagSelectorMenu(\"KEY_CMD\");\n    }\n  }\n\n  handleMouseUp() {\n    const block = this.contentEditable.current;\n    const { selectionStart, selectionEnd } = getSelection(block);\n    if (selectionStart !== selectionEnd) {\n      this.openActionMenu(block, \"TEXT_SELECTION\");\n    }\n  }\n\n  handleDragHandleClick(e) {\n    const dragHandle = e.target;\n    this.openActionMenu(dragHandle, \"DRAG_HANDLE_CLICK\");\n  }\n\n  openActionMenu(parent, trigger) {\n    const { x, y } = this.calculateActionMenuPosition(parent, trigger);\n    this.setState({\n      ...this.state,\n      actionMenuPosition: { x: x, y: y },\n      actionMenuOpen: true,\n    });\n    // Add listener asynchronously to avoid conflicts with\n    // the double click of the text selection\n    setTimeout(() => {\n      document.addEventListener(\"click\", this.closeActionMenu, false);\n    }, 100);\n  }\n\n  closeActionMenu() {\n    this.setState({\n      ...this.state,\n      actionMenuPosition: { x: null, y: null },\n      actionMenuOpen: false,\n    });\n    document.removeEventListener(\"click\", this.closeActionMenu, false);\n  }\n\n  openTagSelectorMenu(trigger) {\n    const { x, y } = this.calculateTagSelectorMenuPosition(trigger);\n    this.setState({\n      ...this.state,\n      tagSelectorMenuPosition: { x: x, y: y },\n      tagSelectorMenuOpen: true,\n    });\n    document.addEventListener(\"click\", this.closeTagSelectorMenu, false);\n  }\n\n  closeTagSelectorMenu() {\n    this.setState({\n      ...this.state,\n      htmlBackup: null,\n      tagSelectorMenuPosition: { x: null, y: null },\n      tagSelectorMenuOpen: false,\n    });\n    document.removeEventListener(\"click\", this.closeTagSelectorMenu, false);\n  }\n\n  // Convert editableBlock shape based on the chosen tag\n  // i.e. img = display <div><input /><img /></div> (input picker is hidden)\n  // i.e. every other tag = <ContentEditable /> with its tag and html content\n  handleTagSelection(tag) {\n    if (tag === \"img\") {\n      this.setState({ ...this.state, tag: tag }, () => {\n        this.closeTagSelectorMenu();\n        if (this.fileInput) {\n          // Open the native file picker\n          this.fileInput.click();\n        }\n        // Add new block so that the user can continue writing\n        // after adding an image\n        this.props.addBlock({\n          id: this.props.id,\n          html: \"\",\n          tag: \"p\",\n          imageUrl: \"\",\n          ref: this.contentEditable.current,\n        });\n      });\n    } else {\n      if (this.state.isTyping) {\n        // Update the tag and restore the html backup without the command\n        this.setState({ tag: tag, html: this.state.htmlBackup }, () => {\n          setCaretToEnd(this.contentEditable.current);\n          this.closeTagSelectorMenu();\n        });\n      } else {\n        this.setState({ ...this.state, tag: tag }, () => {\n          this.closeTagSelectorMenu();\n        });\n      }\n    }\n  }\n\n  async handleImageUpload() {\n    if (this.fileInput && this.fileInput.files[0]) {\n      const pageId = this.props.pageId;\n      const imageFile = this.fileInput.files[0];\n      const formData = new FormData();\n      formData.append(\"image\", imageFile);\n      try {\n        const response = await fetch(\n          `${process.env.NEXT_PUBLIC_API}/pages/images?pageId=${pageId}`,\n          {\n            method: \"POST\",\n            credentials: \"include\",\n            body: formData,\n          }\n        );\n        const data = await response.json();\n        const imageUrl = data.imageUrl;\n        this.setState({ ...this.state, imageUrl: imageUrl });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }\n\n  // Show a placeholder for blank pages\n  addPlaceholder({ block, position, content }) {\n    const isFirstBlockWithoutHtml = position === 1 && !content;\n    const isFirstBlockWithoutSibling = !block.parentElement.nextElementSibling;\n    if (isFirstBlockWithoutHtml && isFirstBlockWithoutSibling) {\n      this.setState({\n        ...this.state,\n        html: \"Type a page title...\",\n        tag: \"h1\",\n        imageUrl: \"\",\n        placeholder: true,\n        isTyping: false,\n      });\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // If we have a text selection, the action menu should be displayed above\n  // If we have a drag handle click, the action menu should be displayed beside\n  calculateActionMenuPosition(parent, initiator) {\n    switch (initiator) {\n      case \"TEXT_SELECTION\":\n        const { x: endX, y: endY } = getCaretCoordinates(false); // fromEnd\n        const { x: startX, y: startY } = getCaretCoordinates(true); // fromStart\n        const middleX = startX + (endX - startX) / 2;\n        return { x: middleX, y: startY };\n      case \"DRAG_HANDLE_CLICK\":\n        const x =\n          parent.offsetLeft - parent.scrollLeft + parent.clientLeft - 90;\n        const y = parent.offsetTop - parent.scrollTop + parent.clientTop + 35;\n        return { x: x, y: y };\n      default:\n        return { x: null, y: null };\n    }\n  }\n\n  // If the user types the \"/\" command, the tag selector menu should be display above\n  // If it is triggered by the action menu, it should be positioned relatively to its initiator\n  calculateTagSelectorMenuPosition(initiator) {\n    switch (initiator) {\n      case \"KEY_CMD\":\n        const { x: caretLeft, y: caretTop } = getCaretCoordinates(true);\n        return { x: caretLeft, y: caretTop };\n      case \"ACTION_MENU\":\n        const { x: actionX, y: actionY } = this.state.actionMenuPosition;\n        return { x: actionX - 40, y: actionY };\n      default:\n        return { x: null, y: null };\n    }\n  }\n\n  render() {\n    return (\n      <>\n        {this.state.tagSelectorMenuOpen && (\n          <TagSelectorMenu\n            position={this.state.tagSelectorMenuPosition}\n            closeMenu={this.closeTagSelectorMenu}\n            handleSelection={this.handleTagSelection}\n          />\n        )}\n        {this.state.actionMenuOpen && (\n          <ActionMenu\n            position={this.state.actionMenuPosition}\n            actions={{\n              deleteBlock: () => this.props.deleteBlock({ id: this.props.id }),\n              turnInto: () => this.openTagSelectorMenu(\"ACTION_MENU\"),\n            }}\n          />\n        )}\n        <Draggable draggableId={this.props.id} index={this.props.position}>\n          {(provided, snapshot) => (\n            <div\n              ref={provided.innerRef}\n              className={styles.draggable}\n              {...provided.draggableProps}\n            >\n              {this.state.tag !== \"img\" && (\n                <ContentEditable\n                  innerRef={this.contentEditable}\n                  data-position={this.props.position}\n                  data-tag={this.state.tag}\n                  html={this.state.html}\n                  onChange={this.handleChange}\n                  onFocus={this.handleFocus}\n                  onBlur={this.handleBlur}\n                  onKeyDown={this.handleKeyDown}\n                  onKeyUp={this.handleKeyUp}\n                  onMouseUp={this.handleMouseUp}\n                  tagName={this.state.tag}\n                  className={[\n                    styles.block,\n                    this.state.isTyping ||\n                    this.state.actionMenuOpen ||\n                    this.state.tagSelectorMenuOpen\n                      ? styles.blockSelected\n                      : null,\n                    this.state.placeholder ? styles.placeholder : null,\n                    snapshot.isDragging ? styles.isDragging : null,\n                  ].join(\" \")}\n                />\n              )}\n              {this.state.tag === \"img\" && (\n                <div\n                  data-position={this.props.position}\n                  data-tag={this.state.tag}\n                  ref={this.contentEditable}\n                  className={[\n                    styles.image,\n                    this.state.actionMenuOpen || this.state.tagSelectorMenuOpen\n                      ? styles.blockSelected\n                      : null,\n                  ].join(\" \")}\n                >\n                  <input\n                    id={`${this.props.id}_fileInput`}\n                    name={this.state.tag}\n                    type=\"file\"\n                    onChange={this.handleImageUpload}\n                    ref={(ref) => (this.fileInput = ref)}\n                    hidden\n                  />\n                  {!this.state.imageUrl && (\n                    <label\n                      htmlFor={`${this.props.id}_fileInput`}\n                      className={styles.fileInputLabel}\n                    >\n                      No Image Selected. Click To Select.\n                    </label>\n                  )}\n                  {this.state.imageUrl && (\n                    <img\n                      src={\n                        process.env.NEXT_PUBLIC_API + \"/\" + this.state.imageUrl\n                      }\n                      alt={/[^\\/]+(?=\\.[^\\/.]*$)/.exec(this.state.imageUrl)[0]}\n                    />\n                  )}\n                </div>\n              )}\n              <span\n                role=\"button\"\n                tabIndex=\"0\"\n                className={styles.dragHandle}\n                onClick={this.handleDragHandleClick}\n                {...provided.dragHandleProps}\n              >\n                <img src={DragHandleIcon} alt=\"Icon\" />\n              </span>\n            </div>\n          )}\n        </Draggable>\n      </>\n    );\n  }\n}\n\nexport default EditableBlock;\n"]},"metadata":{},"sourceType":"module"}