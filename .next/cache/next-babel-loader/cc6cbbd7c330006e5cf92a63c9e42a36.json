{"ast":null,"code":"var _jsxFileName = \"/project/notion-clone/components/editableBlock/index.js\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport ContentEditable from \"react-contenteditable\";\nimport { Draggable } from \"react-beautiful-dnd\";\nimport styles from \"./styles.module.scss\";\nimport TagSelectorMenu from \"../tagSelectorMenu\";\nimport ActionMenu from \"../actionMenu\";\nimport DragHandleIcon from \"../../images/draggable.svg\";\nimport { setCaretToEnd, getCaretCoordinates, getSelection } from \"../../utils\";\nconst CMD_KEY = \"/\"; // library does not work with hooks\n\nclass EditableBlock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleFocus = this.handleFocus.bind(this);\n    this.handleBlur = this.handleBlur.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleKeyUp = this.handleKeyUp.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleDragHandleClick = this.handleDragHandleClick.bind(this);\n    this.openActionMenu = this.openActionMenu.bind(this);\n    this.closeActionMenu = this.closeActionMenu.bind(this);\n    this.openTagSelectorMenu = this.openTagSelectorMenu.bind(this);\n    this.closeTagSelectorMenu = this.closeTagSelectorMenu.bind(this);\n    this.handleTagSelection = this.handleTagSelection.bind(this);\n    this.handleImageUpload = this.handleImageUpload.bind(this);\n    this.addPlaceholder = this.addPlaceholder.bind(this);\n    this.calculateActionMenuPosition = this.calculateActionMenuPosition.bind(this);\n    this.calculateTagSelectorMenuPosition = this.calculateTagSelectorMenuPosition.bind(this);\n    this.contentEditable = React.createRef();\n    this.fileInput = null;\n    this.state = {\n      htmlBackup: null,\n      html: \"\",\n      tag: \"p\",\n      imageUrl: \"\",\n      placeholder: false,\n      previousKey: null,\n      isTyping: false,\n      tagSelectorMenuOpen: false,\n      tagSelectorMenuPosition: {\n        x: null,\n        y: null\n      },\n      actionMenuOpen: false,\n      actionMenuPosition: {\n        x: null,\n        y: null\n      }\n    };\n  } // To avoid unnecessary API calls, the block component fully owns the draft state\n  // i.e. while editing we only update the block component, only when the user\n  // finished editing (e.g. switched to next block), we update the page as well\n  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\n\n\n  componentDidMount() {\n    // Add a placeholder if the first block has no sibling elements and no content\n    const hasPlaceholder = this.addPlaceholder({\n      block: this.contentEditable.current,\n      position: this.props.position,\n      content: this.props.html || this.props.imageUrl\n    });\n\n    if (!hasPlaceholder) {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        html: this.props.html,\n        tag: this.props.tag,\n        imageUrl: this.props.imageUrl\n      }));\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // update the page on the server if one of the following is true\n    // 1. user stopped typing and the html content has changed & no placeholder set\n    // 2. user changed the tag & no placeholder set\n    // 3. user changed the image & no placeholder set\n    const stoppedTyping = prevState.isTyping && !this.state.isTyping;\n    const hasNoPlaceholder = !this.state.placeholder;\n    const htmlChanged = this.props.html !== this.state.html;\n    const tagChanged = this.props.tag !== this.state.tag;\n    const imageChanged = this.props.imageUrl !== this.state.imageUrl;\n\n    if ((stoppedTyping && htmlChanged || tagChanged || imageChanged) && hasNoPlaceholder) {\n      this.props.updateBlock({\n        id: this.props.id,\n        html: this.state.html,\n        tag: this.state.tag,\n        imageUrl: this.state.imageUrl\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    // In case, the user deleted the block, we need to cleanup all listeners\n    document.removeEventListener(\"click\", this.closeActionMenu, false);\n  }\n\n  handleChange(e) {\n    this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n      html: e.target.value\n    }));\n  }\n\n  handleFocus() {\n    // If a placeholder is set, we remove it when the block gets focused\n    if (this.state.placeholder) {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        html: \"\",\n        placeholder: false,\n        isTyping: true\n      }));\n    } else {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        isTyping: true\n      }));\n    }\n  }\n\n  handleBlur(e) {\n    // Show placeholder if block is still the only one and empty\n    const hasPlaceholder = this.addPlaceholder({\n      block: this.contentEditable.current,\n      position: this.props.position,\n      content: this.state.html || this.state.imageUrl\n    });\n\n    if (!hasPlaceholder) {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        isTyping: false\n      }));\n    }\n  }\n\n  handleKeyDown(e) {\n    if (e.key === CMD_KEY) {\n      // If the user starts to enter a command, we store a backup copy of\n      // the html. We need this to restore a clean version of the content\n      // after the content type selection was finished.\n      this.setState({\n        htmlBackup: this.state.html\n      });\n    } else if (e.key === \"Backspace\" && !this.state.html) {\n      this.props.deleteBlock({\n        id: this.props.id\n      });\n    } else if (e.key === \"Enter\" && this.state.previousKey !== \"Shift\" && !this.state.tagSelectorMenuOpen) {\n      // If the user presses Enter, we want to add a new block\n      // Only the Shift-Enter-combination should add a new paragraph,\n      // i.e. Shift-Enter acts as the default enter behaviour\n      e.preventDefault();\n      this.props.addBlock({\n        id: this.props.id,\n        html: this.state.html,\n        tag: this.state.tag,\n        imageUrl: this.state.imageUrl,\n        ref: this.contentEditable.current\n      });\n    } // We need the previousKey to detect a Shift-Enter-combination\n\n\n    this.setState({\n      previousKey: e.key\n    });\n  } // The openTagSelectorMenu function needs to be invoked on key up. Otherwise\n  // the calculation of the caret coordinates does not work properly.\n\n\n  handleKeyUp(e) {\n    if (e.key === CMD_KEY) {\n      this.openTagSelectorMenu(\"KEY_CMD\");\n    }\n  }\n\n  handleMouseUp() {\n    const block = this.contentEditable.current;\n    const {\n      selectionStart,\n      selectionEnd\n    } = getSelection(block);\n\n    if (selectionStart !== selectionEnd) {\n      this.openActionMenu(block, \"TEXT_SELECTION\");\n    }\n  }\n\n  handleDragHandleClick(e) {\n    const dragHandle = e.target;\n    this.openActionMenu(dragHandle, \"DRAG_HANDLE_CLICK\");\n  }\n\n  openActionMenu(parent, trigger) {\n    const {\n      x,\n      y\n    } = this.calculateActionMenuPosition(parent, trigger);\n    this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n      actionMenuPosition: {\n        x: x,\n        y: y\n      },\n      actionMenuOpen: true\n    })); // Add listener asynchronously to avoid conflicts with\n    // the double click of the text selection\n\n    setTimeout(() => {\n      document.addEventListener(\"click\", this.closeActionMenu, false);\n    }, 100);\n  }\n\n  closeActionMenu() {\n    this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n      actionMenuPosition: {\n        x: null,\n        y: null\n      },\n      actionMenuOpen: false\n    }));\n    document.removeEventListener(\"click\", this.closeActionMenu, false);\n  }\n\n  openTagSelectorMenu(trigger) {\n    const {\n      x,\n      y\n    } = this.calculateTagSelectorMenuPosition(trigger);\n    this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n      tagSelectorMenuPosition: {\n        x: x,\n        y: y\n      },\n      tagSelectorMenuOpen: true\n    }));\n    document.addEventListener(\"click\", this.closeTagSelectorMenu, false);\n  }\n\n  closeTagSelectorMenu() {\n    this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n      htmlBackup: null,\n      tagSelectorMenuPosition: {\n        x: null,\n        y: null\n      },\n      tagSelectorMenuOpen: false\n    }));\n    document.removeEventListener(\"click\", this.closeTagSelectorMenu, false);\n  } // Convert editableBlock shape based on the chosen tag\n  // i.e. img = display <div><input /><img /></div> (input picker is hidden)\n  // i.e. every other tag = <ContentEditable /> with its tag and html content\n\n\n  handleTagSelection(tag) {\n    if (tag === \"img\") {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        tag: tag\n      }), () => {\n        this.closeTagSelectorMenu();\n\n        if (this.fileInput) {\n          // Open the native file picker\n          this.fileInput.click();\n        } // Add new block so that the user can continue writing\n        // after adding an image\n\n\n        this.props.addBlock({\n          id: this.props.id,\n          html: \"\",\n          tag: \"p\",\n          imageUrl: \"\",\n          ref: this.contentEditable.current\n        });\n      });\n    } else {\n      if (this.state.isTyping) {\n        // Update the tag and restore the html backup without the command\n        this.setState({\n          tag: tag,\n          html: this.state.htmlBackup\n        }, () => {\n          setCaretToEnd(this.contentEditable.current);\n          this.closeTagSelectorMenu();\n        });\n      } else {\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          tag: tag\n        }), () => {\n          this.closeTagSelectorMenu();\n        });\n      }\n    }\n  }\n\n  async handleImageUpload() {\n    if (this.fileInput && this.fileInput.files[0]) {\n      const pageId = this.props.pageId;\n      const imageFile = this.fileInput.files[0];\n      const formData = new FormData();\n      formData.append(\"image\", imageFile);\n\n      try {\n        const response = await fetch(`${process.env.NEXT_PUBLIC_API}/pages/images?pageId=${pageId}`, {\n          method: \"POST\",\n          credentials: \"include\",\n          body: formData\n        });\n        const data = await response.json();\n        const imageUrl = data.imageUrl;\n        this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n          imageUrl: imageUrl\n        }));\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  } // Show a placeholder for blank pages\n\n\n  addPlaceholder({\n    block,\n    position,\n    content\n  }) {\n    const isFirstBlockWithoutHtml = position === 1 && !content;\n    const isFirstBlockWithoutSibling = !block.parentElement.nextElementSibling;\n\n    if (isFirstBlockWithoutHtml && isFirstBlockWithoutSibling) {\n      this.setState(_objectSpread(_objectSpread({}, this.state), {}, {\n        html: \"Type a page title...\",\n        tag: \"h1\",\n        imageUrl: \"\",\n        placeholder: true,\n        isTyping: false\n      }));\n      return true;\n    } else {\n      return false;\n    }\n  } // If we have a text selection, the action menu should be displayed above\n  // If we have a drag handle click, the action menu should be displayed beside\n\n\n  calculateActionMenuPosition(parent, initiator) {\n    switch (initiator) {\n      case \"TEXT_SELECTION\":\n        const {\n          x: endX,\n          y: endY\n        } = getCaretCoordinates(false); // fromEnd\n\n        const {\n          x: startX,\n          y: startY\n        } = getCaretCoordinates(true); // fromStart\n\n        const middleX = startX + (endX - startX) / 2;\n        return {\n          x: middleX,\n          y: startY\n        };\n\n      case \"DRAG_HANDLE_CLICK\":\n        const x = parent.offsetLeft - parent.scrollLeft + parent.clientLeft - 90;\n        const y = parent.offsetTop - parent.scrollTop + parent.clientTop + 35;\n        return {\n          x: x,\n          y: y\n        };\n\n      default:\n        return {\n          x: null,\n          y: null\n        };\n    }\n  } // If the user types the \"/\" command, the tag selector menu should be display above\n  // If it is triggered by the action menu, it should be positioned relatively to its initiator\n\n\n  calculateTagSelectorMenuPosition(initiator) {\n    switch (initiator) {\n      case \"KEY_CMD\":\n        const {\n          x: caretLeft,\n          y: caretTop\n        } = getCaretCoordinates(true);\n        return {\n          x: caretLeft,\n          y: caretTop\n        };\n\n      case \"ACTION_MENU\":\n        const {\n          x: actionX,\n          y: actionY\n        } = this.state.actionMenuPosition;\n        return {\n          x: actionX - 40,\n          y: actionY\n        };\n\n      default:\n        return {\n          x: null,\n          y: null\n        };\n    }\n  }\n\n  render() {\n    return __jsx(React.Fragment, null, this.state.tagSelectorMenuOpen && __jsx(TagSelectorMenu, {\n      position: this.state.tagSelectorMenuPosition,\n      closeMenu: this.closeTagSelectorMenu,\n      handleSelection: this.handleTagSelection,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 349,\n        columnNumber: 11\n      }\n    }), this.state.actionMenuOpen && __jsx(ActionMenu, {\n      position: this.state.actionMenuPosition,\n      actions: {\n        deleteBlock: () => this.props.deleteBlock({\n          id: this.props.id\n        }),\n        turnInto: () => this.openTagSelectorMenu(\"ACTION_MENU\")\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 356,\n        columnNumber: 11\n      }\n    }), __jsx(Draggable, {\n      draggableId: this.props.id,\n      index: this.props.position,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 364,\n        columnNumber: 9\n      }\n    }, (provided, snapshot) => __jsx(\"div\", _extends({\n      ref: provided.innerRef,\n      className: styles.draggable\n    }, provided.draggableProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 366,\n        columnNumber: 13\n      }\n    }), this.state.tag !== \"img\" && __jsx(ContentEditable, {\n      innerRef: this.contentEditable,\n      \"data-position\": this.props.position,\n      \"data-tag\": this.state.tag,\n      html: this.state.html,\n      onChange: this.handleChange,\n      onFocus: this.handleFocus,\n      onBlur: this.handleBlur,\n      onKeyDown: this.handleKeyDown,\n      onKeyUp: this.handleKeyUp,\n      onMouseUp: this.handleMouseUp,\n      tagName: this.state.tag,\n      className: [styles.block, this.state.isTyping || this.state.actionMenuOpen || this.state.tagSelectorMenuOpen ? styles.blockSelected : null, this.state.placeholder ? styles.placeholder : null, snapshot.isDragging ? styles.isDragging : null].join(\" \"),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 372,\n        columnNumber: 17\n      }\n    }), this.state.tag === \"img\" && __jsx(\"div\", {\n      \"data-position\": this.props.position,\n      \"data-tag\": this.state.tag,\n      ref: this.contentEditable,\n      className: [styles.image, this.state.actionMenuOpen || this.state.tagSelectorMenuOpen ? styles.blockSelected : null].join(\" \"),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 397,\n        columnNumber: 17\n      }\n    }, __jsx(\"input\", {\n      id: `${this.props.id}_fileInput`,\n      name: this.state.tag,\n      type: \"file\",\n      onChange: this.handleImageUpload,\n      ref: ref => this.fileInput = ref,\n      hidden: true,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 408,\n        columnNumber: 19\n      }\n    }), !this.state.imageUrl && __jsx(\"label\", {\n      htmlFor: `${this.props.id}_fileInput`,\n      className: styles.fileInputLabel,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 417,\n        columnNumber: 21\n      }\n    }, \"No Image Selected. Click To Select.\"), this.state.imageUrl && __jsx(\"img\", {\n      src: process.env.NEXT_PUBLIC_API + \"/\" + this.state.imageUrl,\n      alt: /[^\\/]+(?=\\.[^\\/.]*$)/.exec(this.state.imageUrl)[0],\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 425,\n        columnNumber: 21\n      }\n    })), __jsx(\"span\", _extends({\n      role: \"button\",\n      tabIndex: \"0\",\n      className: styles.dragHandle,\n      onClick: this.handleDragHandleClick\n    }, provided.dragHandleProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 434,\n        columnNumber: 15\n      }\n    }), __jsx(\"img\", {\n      src: DragHandleIcon,\n      alt: \"Icon\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 441,\n        columnNumber: 17\n      }\n    })))));\n  }\n\n}\n\nexport default EditableBlock;","map":{"version":3,"sources":["/project/notion-clone/components/editableBlock/index.js"],"names":["ContentEditable","Draggable","styles","TagSelectorMenu","ActionMenu","DragHandleIcon","setCaretToEnd","getCaretCoordinates","getSelection","CMD_KEY","EditableBlock","React","Component","constructor","props","handleChange","bind","handleFocus","handleBlur","handleKeyDown","handleKeyUp","handleMouseUp","handleDragHandleClick","openActionMenu","closeActionMenu","openTagSelectorMenu","closeTagSelectorMenu","handleTagSelection","handleImageUpload","addPlaceholder","calculateActionMenuPosition","calculateTagSelectorMenuPosition","contentEditable","createRef","fileInput","state","htmlBackup","html","tag","imageUrl","placeholder","previousKey","isTyping","tagSelectorMenuOpen","tagSelectorMenuPosition","x","y","actionMenuOpen","actionMenuPosition","componentDidMount","hasPlaceholder","block","current","position","content","setState","componentDidUpdate","prevProps","prevState","stoppedTyping","hasNoPlaceholder","htmlChanged","tagChanged","imageChanged","updateBlock","id","componentWillUnmount","document","removeEventListener","e","target","value","key","deleteBlock","preventDefault","addBlock","ref","selectionStart","selectionEnd","dragHandle","parent","trigger","setTimeout","addEventListener","click","files","pageId","imageFile","formData","FormData","append","response","fetch","process","env","NEXT_PUBLIC_API","method","credentials","body","data","json","err","console","log","isFirstBlockWithoutHtml","isFirstBlockWithoutSibling","parentElement","nextElementSibling","initiator","endX","endY","startX","startY","middleX","offsetLeft","scrollLeft","clientLeft","offsetTop","scrollTop","clientTop","caretLeft","caretTop","actionX","actionY","render","turnInto","provided","snapshot","innerRef","draggable","draggableProps","blockSelected","isDragging","join","image","fileInputLabel","exec","dragHandleProps"],"mappings":"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","sourcesContent":["import ContentEditable from \"react-contenteditable\";\nimport { Draggable } from \"react-beautiful-dnd\";\n\nimport styles from \"./styles.module.scss\";\nimport TagSelectorMenu from \"../tagSelectorMenu\";\nimport ActionMenu from \"../actionMenu\";\nimport DragHandleIcon from \"../../images/draggable.svg\";\nimport { setCaretToEnd, getCaretCoordinates, getSelection } from \"../../utils\";\n\nconst CMD_KEY = \"/\";\n\n// library does not work with hooks\nclass EditableBlock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleFocus = this.handleFocus.bind(this);\n    this.handleBlur = this.handleBlur.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleKeyUp = this.handleKeyUp.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleDragHandleClick = this.handleDragHandleClick.bind(this);\n    this.openActionMenu = this.openActionMenu.bind(this);\n    this.closeActionMenu = this.closeActionMenu.bind(this);\n    this.openTagSelectorMenu = this.openTagSelectorMenu.bind(this);\n    this.closeTagSelectorMenu = this.closeTagSelectorMenu.bind(this);\n    this.handleTagSelection = this.handleTagSelection.bind(this);\n    this.handleImageUpload = this.handleImageUpload.bind(this);\n    this.addPlaceholder = this.addPlaceholder.bind(this);\n    this.calculateActionMenuPosition = this.calculateActionMenuPosition.bind(\n      this\n    );\n    this.calculateTagSelectorMenuPosition = this.calculateTagSelectorMenuPosition.bind(\n      this\n    );\n    this.contentEditable = React.createRef();\n    this.fileInput = null;\n    this.state = {\n      htmlBackup: null,\n      html: \"\",\n      tag: \"p\",\n      imageUrl: \"\",\n      placeholder: false,\n      previousKey: null,\n      isTyping: false,\n      tagSelectorMenuOpen: false,\n      tagSelectorMenuPosition: {\n        x: null,\n        y: null,\n      },\n      actionMenuOpen: false,\n      actionMenuPosition: {\n        x: null,\n        y: null,\n      },\n    };\n  }\n\n  // To avoid unnecessary API calls, the block component fully owns the draft state\n  // i.e. while editing we only update the block component, only when the user\n  // finished editing (e.g. switched to next block), we update the page as well\n  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html\n\n  componentDidMount() {\n    // Add a placeholder if the first block has no sibling elements and no content\n    const hasPlaceholder = this.addPlaceholder({\n      block: this.contentEditable.current,\n      position: this.props.position,\n      content: this.props.html || this.props.imageUrl,\n    });\n    if (!hasPlaceholder) {\n      this.setState({\n        ...this.state,\n        html: this.props.html,\n        tag: this.props.tag,\n        imageUrl: this.props.imageUrl,\n      });\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // update the page on the server if one of the following is true\n    // 1. user stopped typing and the html content has changed & no placeholder set\n    // 2. user changed the tag & no placeholder set\n    // 3. user changed the image & no placeholder set\n    const stoppedTyping = prevState.isTyping && !this.state.isTyping;\n    const hasNoPlaceholder = !this.state.placeholder;\n    const htmlChanged = this.props.html !== this.state.html;\n    const tagChanged = this.props.tag !== this.state.tag;\n    const imageChanged = this.props.imageUrl !== this.state.imageUrl;\n    if (\n      ((stoppedTyping && htmlChanged) || tagChanged || imageChanged) &&\n      hasNoPlaceholder\n    ) {\n      this.props.updateBlock({\n        id: this.props.id,\n        html: this.state.html,\n        tag: this.state.tag,\n        imageUrl: this.state.imageUrl,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    // In case, the user deleted the block, we need to cleanup all listeners\n    document.removeEventListener(\"click\", this.closeActionMenu, false);\n  }\n\n  handleChange(e) {\n    this.setState({ ...this.state, html: e.target.value });\n  }\n\n  handleFocus() {\n    // If a placeholder is set, we remove it when the block gets focused\n    if (this.state.placeholder) {\n      this.setState({\n        ...this.state,\n        html: \"\",\n        placeholder: false,\n        isTyping: true,\n      });\n    } else {\n      this.setState({ ...this.state, isTyping: true });\n    }\n  }\n\n  handleBlur(e) {\n    // Show placeholder if block is still the only one and empty\n    const hasPlaceholder = this.addPlaceholder({\n      block: this.contentEditable.current,\n      position: this.props.position,\n      content: this.state.html || this.state.imageUrl,\n    });\n    if (!hasPlaceholder) {\n      this.setState({ ...this.state, isTyping: false });\n    }\n  }\n\n  handleKeyDown(e) {\n    if (e.key === CMD_KEY) {\n      // If the user starts to enter a command, we store a backup copy of\n      // the html. We need this to restore a clean version of the content\n      // after the content type selection was finished.\n      this.setState({ htmlBackup: this.state.html });\n    } else if (e.key === \"Backspace\" && !this.state.html) {\n      this.props.deleteBlock({ id: this.props.id });\n    } else if (\n      e.key === \"Enter\" &&\n      this.state.previousKey !== \"Shift\" &&\n      !this.state.tagSelectorMenuOpen\n    ) {\n      // If the user presses Enter, we want to add a new block\n      // Only the Shift-Enter-combination should add a new paragraph,\n      // i.e. Shift-Enter acts as the default enter behaviour\n      e.preventDefault();\n      this.props.addBlock({\n        id: this.props.id,\n        html: this.state.html,\n        tag: this.state.tag,\n        imageUrl: this.state.imageUrl,\n        ref: this.contentEditable.current,\n      });\n    }\n    // We need the previousKey to detect a Shift-Enter-combination\n    this.setState({ previousKey: e.key });\n  }\n\n  // The openTagSelectorMenu function needs to be invoked on key up. Otherwise\n  // the calculation of the caret coordinates does not work properly.\n  handleKeyUp(e) {\n    if (e.key === CMD_KEY) {\n      this.openTagSelectorMenu(\"KEY_CMD\");\n    }\n  }\n\n  handleMouseUp() {\n    const block = this.contentEditable.current;\n    const { selectionStart, selectionEnd } = getSelection(block);\n    if (selectionStart !== selectionEnd) {\n      this.openActionMenu(block, \"TEXT_SELECTION\");\n    }\n  }\n\n  handleDragHandleClick(e) {\n    const dragHandle = e.target;\n    this.openActionMenu(dragHandle, \"DRAG_HANDLE_CLICK\");\n  }\n\n  openActionMenu(parent, trigger) {\n    const { x, y } = this.calculateActionMenuPosition(parent, trigger);\n    this.setState({\n      ...this.state,\n      actionMenuPosition: { x: x, y: y },\n      actionMenuOpen: true,\n    });\n    // Add listener asynchronously to avoid conflicts with\n    // the double click of the text selection\n    setTimeout(() => {\n      document.addEventListener(\"click\", this.closeActionMenu, false);\n    }, 100);\n  }\n\n  closeActionMenu() {\n    this.setState({\n      ...this.state,\n      actionMenuPosition: { x: null, y: null },\n      actionMenuOpen: false,\n    });\n    document.removeEventListener(\"click\", this.closeActionMenu, false);\n  }\n\n  openTagSelectorMenu(trigger) {\n    const { x, y } = this.calculateTagSelectorMenuPosition(trigger);\n    this.setState({\n      ...this.state,\n      tagSelectorMenuPosition: { x: x, y: y },\n      tagSelectorMenuOpen: true,\n    });\n    document.addEventListener(\"click\", this.closeTagSelectorMenu, false);\n  }\n\n  closeTagSelectorMenu() {\n    this.setState({\n      ...this.state,\n      htmlBackup: null,\n      tagSelectorMenuPosition: { x: null, y: null },\n      tagSelectorMenuOpen: false,\n    });\n    document.removeEventListener(\"click\", this.closeTagSelectorMenu, false);\n  }\n\n  // Convert editableBlock shape based on the chosen tag\n  // i.e. img = display <div><input /><img /></div> (input picker is hidden)\n  // i.e. every other tag = <ContentEditable /> with its tag and html content\n  handleTagSelection(tag) {\n    if (tag === \"img\") {\n      this.setState({ ...this.state, tag: tag }, () => {\n        this.closeTagSelectorMenu();\n        if (this.fileInput) {\n          // Open the native file picker\n          this.fileInput.click();\n        }\n        // Add new block so that the user can continue writing\n        // after adding an image\n        this.props.addBlock({\n          id: this.props.id,\n          html: \"\",\n          tag: \"p\",\n          imageUrl: \"\",\n          ref: this.contentEditable.current,\n        });\n      });\n    } else {\n      if (this.state.isTyping) {\n        // Update the tag and restore the html backup without the command\n        this.setState({ tag: tag, html: this.state.htmlBackup }, () => {\n          setCaretToEnd(this.contentEditable.current);\n          this.closeTagSelectorMenu();\n        });\n      } else {\n        this.setState({ ...this.state, tag: tag }, () => {\n          this.closeTagSelectorMenu();\n        });\n      }\n    }\n  }\n\n  async handleImageUpload() {\n    if (this.fileInput && this.fileInput.files[0]) {\n      const pageId = this.props.pageId;\n      const imageFile = this.fileInput.files[0];\n      const formData = new FormData();\n      formData.append(\"image\", imageFile);\n      try {\n        const response = await fetch(\n          `${process.env.NEXT_PUBLIC_API}/pages/images?pageId=${pageId}`,\n          {\n            method: \"POST\",\n            credentials: \"include\",\n            body: formData,\n          }\n        );\n        const data = await response.json();\n        const imageUrl = data.imageUrl;\n        this.setState({ ...this.state, imageUrl: imageUrl });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }\n\n  // Show a placeholder for blank pages\n  addPlaceholder({ block, position, content }) {\n    const isFirstBlockWithoutHtml = position === 1 && !content;\n    const isFirstBlockWithoutSibling = !block.parentElement.nextElementSibling;\n    if (isFirstBlockWithoutHtml && isFirstBlockWithoutSibling) {\n      this.setState({\n        ...this.state,\n        html: \"Type a page title...\",\n        tag: \"h1\",\n        imageUrl: \"\",\n        placeholder: true,\n        isTyping: false,\n      });\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // If we have a text selection, the action menu should be displayed above\n  // If we have a drag handle click, the action menu should be displayed beside\n  calculateActionMenuPosition(parent, initiator) {\n    switch (initiator) {\n      case \"TEXT_SELECTION\":\n        const { x: endX, y: endY } = getCaretCoordinates(false); // fromEnd\n        const { x: startX, y: startY } = getCaretCoordinates(true); // fromStart\n        const middleX = startX + (endX - startX) / 2;\n        return { x: middleX, y: startY };\n      case \"DRAG_HANDLE_CLICK\":\n        const x =\n          parent.offsetLeft - parent.scrollLeft + parent.clientLeft - 90;\n        const y = parent.offsetTop - parent.scrollTop + parent.clientTop + 35;\n        return { x: x, y: y };\n      default:\n        return { x: null, y: null };\n    }\n  }\n\n  // If the user types the \"/\" command, the tag selector menu should be display above\n  // If it is triggered by the action menu, it should be positioned relatively to its initiator\n  calculateTagSelectorMenuPosition(initiator) {\n    switch (initiator) {\n      case \"KEY_CMD\":\n        const { x: caretLeft, y: caretTop } = getCaretCoordinates(true);\n        return { x: caretLeft, y: caretTop };\n      case \"ACTION_MENU\":\n        const { x: actionX, y: actionY } = this.state.actionMenuPosition;\n        return { x: actionX - 40, y: actionY };\n      default:\n        return { x: null, y: null };\n    }\n  }\n\n  render() {\n    return (\n      <>\n        {this.state.tagSelectorMenuOpen && (\n          <TagSelectorMenu\n            position={this.state.tagSelectorMenuPosition}\n            closeMenu={this.closeTagSelectorMenu}\n            handleSelection={this.handleTagSelection}\n          />\n        )}\n        {this.state.actionMenuOpen && (\n          <ActionMenu\n            position={this.state.actionMenuPosition}\n            actions={{\n              deleteBlock: () => this.props.deleteBlock({ id: this.props.id }),\n              turnInto: () => this.openTagSelectorMenu(\"ACTION_MENU\"),\n            }}\n          />\n        )}\n        <Draggable draggableId={this.props.id} index={this.props.position}>\n          {(provided, snapshot) => (\n            <div\n              ref={provided.innerRef}\n              className={styles.draggable}\n              {...provided.draggableProps}\n            >\n              {this.state.tag !== \"img\" && (\n                <ContentEditable\n                  innerRef={this.contentEditable}\n                  data-position={this.props.position}\n                  data-tag={this.state.tag}\n                  html={this.state.html}\n                  onChange={this.handleChange}\n                  onFocus={this.handleFocus}\n                  onBlur={this.handleBlur}\n                  onKeyDown={this.handleKeyDown}\n                  onKeyUp={this.handleKeyUp}\n                  onMouseUp={this.handleMouseUp}\n                  tagName={this.state.tag}\n                  className={[\n                    styles.block,\n                    this.state.isTyping ||\n                    this.state.actionMenuOpen ||\n                    this.state.tagSelectorMenuOpen\n                      ? styles.blockSelected\n                      : null,\n                    this.state.placeholder ? styles.placeholder : null,\n                    snapshot.isDragging ? styles.isDragging : null,\n                  ].join(\" \")}\n                />\n              )}\n              {this.state.tag === \"img\" && (\n                <div\n                  data-position={this.props.position}\n                  data-tag={this.state.tag}\n                  ref={this.contentEditable}\n                  className={[\n                    styles.image,\n                    this.state.actionMenuOpen || this.state.tagSelectorMenuOpen\n                      ? styles.blockSelected\n                      : null,\n                  ].join(\" \")}\n                >\n                  <input\n                    id={`${this.props.id}_fileInput`}\n                    name={this.state.tag}\n                    type=\"file\"\n                    onChange={this.handleImageUpload}\n                    ref={(ref) => (this.fileInput = ref)}\n                    hidden\n                  />\n                  {!this.state.imageUrl && (\n                    <label\n                      htmlFor={`${this.props.id}_fileInput`}\n                      className={styles.fileInputLabel}\n                    >\n                      No Image Selected. Click To Select.\n                    </label>\n                  )}\n                  {this.state.imageUrl && (\n                    <img\n                      src={\n                        process.env.NEXT_PUBLIC_API + \"/\" + this.state.imageUrl\n                      }\n                      alt={/[^\\/]+(?=\\.[^\\/.]*$)/.exec(this.state.imageUrl)[0]}\n                    />\n                  )}\n                </div>\n              )}\n              <span\n                role=\"button\"\n                tabIndex=\"0\"\n                className={styles.dragHandle}\n                onClick={this.handleDragHandleClick}\n                {...provided.dragHandleProps}\n              >\n                <img src={DragHandleIcon} alt=\"Icon\" />\n              </span>\n            </div>\n          )}\n        </Draggable>\n      </>\n    );\n  }\n}\n\nexport default EditableBlock;\n"]},"metadata":{},"sourceType":"module"}